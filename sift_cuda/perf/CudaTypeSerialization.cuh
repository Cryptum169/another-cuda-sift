#pragma once

#include <msgpack.hpp>
#include <cuda_runtime.h>
#include <cuda_fp16.h>
#include <iostream>

// Custom packing for CUDA types
// This is generated by Claude
namespace msgpack {
    MSGPACK_API_VERSION_NAMESPACE(MSGPACK_DEFAULT_API_NS) {
        namespace adaptor {
            template<>
            struct pack<float3> {
                template <typename Stream>
                packer<Stream>& operator()(msgpack::packer<Stream>& o, const float3& v) const {
                    o.pack_array(3);
                    o.pack(v.x);
                    o.pack(v.y);
                    o.pack(v.z);
                    return o;
                }
            };

            template<>
            struct convert<float3> {
                msgpack::object const& operator()(msgpack::object const& o, float3& v) const {
                    if (o.type != msgpack::type::ARRAY) throw msgpack::type_error();
                    if (o.via.array.size != 3) throw msgpack::type_error();
                    
                    v.x = o.via.array.ptr[0].as<float>();
                    v.y = o.via.array.ptr[1].as<float>();
                    v.z = o.via.array.ptr[2].as<float>();
                    return o;
                }
            };

            template<>
            struct pack<float4> {
                template <typename Stream>
                packer<Stream>& operator()(msgpack::packer<Stream>& o, const float4& v) const {
                    o.pack_array(4);
                    o.pack(v.x);
                    o.pack(v.y);
                    o.pack(v.z);
                    o.pack(v.w);
                    return o;
                }
            };

            template<>
            struct convert<float4> {
                msgpack::object const& operator()(msgpack::object const& o, float4& v) const {
                    if (o.type != msgpack::type::ARRAY) throw msgpack::type_error();
                    if (o.via.array.size != 4) throw msgpack::type_error();
                    
                    v.x = o.via.array.ptr[0].as<float>();
                    v.y = o.via.array.ptr[1].as<float>();
                    v.z = o.via.array.ptr[2].as<float>();
                    v.w = o.via.array.ptr[3].as<float>();
                    return o;
                }
            };

            template<>
            struct pack<__half> {
                template <typename Stream>
                packer<Stream>& operator()(msgpack::packer<Stream>& o, const __half& v) const {
                    // Convert half to float for serialization
                    float float_val = __half2float(v);
                    o.pack_float(float_val);
                    return o;
                }
            };

            template<>
            struct convert<std::vector<__half>> {
                msgpack::object const& operator()(msgpack::object const& o, std::vector<__half>& v) const {
                    if (o.type != msgpack::type::ARRAY) {
                        throw msgpack::type_error();
                    }
                    
                    const size_t size = o.via.array.size;
                    
                    v.clear();
                    v.reserve(size);
                    
                    for(size_t i = 0; i < size; ++i) {
                        if (i >= o.via.array.size) {
                            std::cerr << "Error: Trying to access beyond array bounds at index " << i << std::endl;
                            break;
                        }
                        
                        const msgpack::object& elem = o.via.array.ptr[i];
                        float float_val = elem.as<float>();
                        v.push_back(__float2half(float_val));
                       
                    }
                    
                    return o;
                }
            };
        }
    }
}
